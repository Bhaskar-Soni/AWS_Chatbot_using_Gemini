import streamlit as st
import boto3
from cryptography.fernet import Fernet
from config import CREDENTIALS_FILE, ENCRYPTION_KEY_FILE

# Function to load encryption key
def load_key():
    with open(ENCRYPTION_KEY_FILE, 'rb') as f:
        return f.read()

# Initialize Fernet cipher suite with loaded encryption key
key = load_key()
cipher_suite = Fernet(key)

# Function to decrypt data
def decrypt_data(encrypted_data):
    decrypted_data = cipher_suite.decrypt(encrypted_data.encode())
    return decrypted_data.decode()

# Function to load credentials from file and decrypt them
def load_credentials():
    with open(CREDENTIALS_FILE, 'r') as f:
        lines = f.readlines()
        access_key = decrypt_data(lines[0].split(': ')[1].strip())
        secret_key = decrypt_data(lines[1].split(': ')[1].strip())
        region = lines[2].split(': ')[1].strip()
        return access_key, secret_key, region

# Load and decrypt credentials
#aws_access_key_id, aws_secret_access_key, region = load_credentials()

# Function to check security groups for common misconfigurations
def check_security_groups(ec2_client):
    st.subheader("Security Groups")
    security_groups = ec2_client.describe_security_groups()['SecurityGroups']
    misconfigurations_found = False
    for sg in security_groups:
        st.write(f"Security Group ID: {sg['GroupId']}")
        st.write(f"Description: {sg['Description']}")
        st.write("Inbound Rules:")
        for rule in sg['IpPermissions']:
            # Check for misconfigurations
            if ('FromPort' in rule) and (rule['IpProtocol'] == '-1' or '0.0.0.0/0' in [ip_range['CidrIp'] for ip_range in rule.get('IpRanges', [])]):
                misconfigurations_found = True
                st.error("Misconfiguration found:")
                st.error(f"- Security Group {sg['GroupId']} allows unrestricted access on port {rule['FromPort']}-{rule['ToPort']} ({rule['IpProtocol']})")
        st.write("Outbound Rules:")
        for rule in sg['IpPermissionsEgress']:
            # Check for misconfigurations
            if ('FromPort' in rule) and (rule['IpProtocol'] == '-1' or '0.0.0.0/0' in [ip_range['CidrIp'] for ip_range in rule.get('IpRanges', [])]):
                misconfigurations_found = True
                st.error("Misconfiguration found:")
                st.error(f"- Security Group {sg['GroupId']} allows unrestricted outbound access on port {rule['FromPort']}-{rule['ToPort']} ({rule['IpProtocol']})")
    if not misconfigurations_found:
        st.success("No misconfigurations found in security groups.")

# Function to check if any security group allows all traffic
def check_all_traffic_security_groups(ec2_client):
    st.subheader("Security Group Rules - All Traffic")
    security_groups = ec2_client.describe_security_groups()['SecurityGroups']
    all_traffic_found = False
    for sg in security_groups:
        for rule in sg['IpPermissions']:
            if rule.get('IpProtocol') == '-1' and len(rule.get('IpRanges', [])) == 1 and rule['IpRanges'][0]['CidrIp'] == '0.0.0.0/0':
                all_traffic_found = True
                st.error(f"Security Group {sg['GroupId']} allows all traffic.")
                break
    if not all_traffic_found:
        st.success("No security groups allowing all traffic found.")

# Function to check for open ports in security groups
def check_open_ports(ec2_client):
    st.subheader("Open Ports")
    security_groups = ec2_client.describe_security_groups()['SecurityGroups']
    open_ports_found = False
    for sg in security_groups:
        for rule in sg['IpPermissions']:
            if 'FromPort' in rule and 'ToPort' in rule and rule['FromPort'] == rule['ToPort']:
                open_ports_found = True
                st.error(f"Security Group {sg['GroupId']} has open port: {rule['FromPort']} ({rule['IpProtocol']})")
    if not open_ports_found:
        st.success("No open ports found in security groups.")

# Function to check IAM roles and policies
def check_iam_roles_policies(iam_client):
    st.subheader("IAM Roles and Policies")
    roles = iam_client.list_roles()['Roles']
    misconfigurations_found = False
    for role in roles:
        role_name = role['RoleName']
        role_policies = iam_client.list_attached_role_policies(RoleName=role_name)['AttachedPolicies']
        if not role_policies:
            misconfigurations_found = True
            st.error(f"IAM Role {role_name} has no attached policies.")
    if not misconfigurations_found:
        st.success("No misconfigurations found in IAM roles and policies.")

# Function to check if EBS volumes are encrypted
def check_ebs_encryption(ec2_client):
    st.subheader("EBS Encryption")
    volumes = ec2_client.describe_volumes()['Volumes']
    unencrypted_volumes_found = False
    for volume in volumes:
        if 'Encrypted' in volume and not volume['Encrypted']:
            unencrypted_volumes_found = True
            st.error(f"EBS Volume {volume['VolumeId']} is not encrypted.")
    if not unencrypted_volumes_found:
        st.success("All EBS volumes are encrypted.")

# Function to check if instance is in a VPC with only one subnet
def check_single_subnet_vpc(ec2_client):
    st.subheader("Network Configuration - Single Subnet VPC")
    vpcs = ec2_client.describe_vpcs()['Vpcs']
    single_subnet_vpc_found = False
    for vpc in vpcs:
        subnets = ec2_client.describe_subnets(Filters=[{'Name': 'vpc-id', 'Values': [vpc['VpcId']]}])['Subnets']
        if len(subnets) == 1:
            single_subnet_vpc_found = True
            st.error(f"VPC {vpc['VpcId']} has only one subnet.")
    if not single_subnet_vpc_found:
        st.success("All VPCs have multiple subnets.")

# Function to check if Instance Metadata Service version 2 (IMDSv2) is enabled
def check_imds_restriction(ec2_client):
    st.subheader("Instance Metadata Service (IMDS) Restriction")
    try:
        response = ec2_client.describe_instance_metadata_options()
        if response['InstanceMetadataOptions']['HttpTokens'] == 'required':
            st.success("Instance Metadata Service (IMDSv2) restriction is enabled.")
        else:
            st.error("Instance Metadata Service (IMDSv2) restriction is not enabled.")
    except Exception as e:
        st.error(f"Error checking IMDS restriction: {str(e)}")

# Function to check security patching status
def check_security_patching(ec2_client):
    st.subheader("Security Patching")
    try:
        response = ec2_client.describe_instance_patch_states()
        instances_needing_patching = [instance for instance in response['InstancePatchStates'] if instance['MissingCount'] > 0]
        if instances_needing_patching:
            st.error(f"There are instances that need security patching: {', '.join([instance['InstanceId'] for instance in instances_needing_patching])}")
        else:
            st.success("All instances are up-to-date with security patches.")
    except Exception as e:
        st.error(f"Error checking security patching: {str(e)}")

# Function to check if instance termination protection is enabled
def check_termination_protection(ec2_client):
    st.subheader("Instance Termination Protection")
    try:
        response = ec2_client.describe_instances()
        instances_with_termination_protection = [instance['InstanceId'] for reservation in response['Reservations'] for instance in reservation['Instances'] if instance.get('InstanceLifecycle') == 'spot']
        if instances_with_termination_protection:
            st.success(f"Instance termination protection is enabled for: {', '.join(instances_with_termination_protection)}")
        else:
            st.error("Instance termination protection is not enabled for any instance.")
    except Exception as e:
        st.error(f"Error checking termination protection: {str(e)}")

# Function to check ELB configurations
def check_elb_configuration(elb_client):
    st.subheader("Elastic Load Balancer (ELB) Configuration")
    try:
        response = elb_client.describe_load_balancers()
        
        for elb in response['LoadBalancerDescriptions']:
            elb_name = elb['LoadBalancerName']
            st.write(f"Load Balancer: {elb_name}")

            # Check for security groups
            security_groups = elb.get('SecurityGroups', [])
            if not security_groups:
                st.error(f"No security groups attached to {elb_name}.")
            else:
                st.success(f"Security groups attached to {elb_name}: {', '.join(security_groups)}")

            # Check for listeners
            listeners = elb.get('ListenerDescriptions', [])
            if not listeners:
                st.error(f"No listeners configured for {elb_name}.")
            else:
                st.success(f"{len(listeners)} listener(s) configured for {elb_name}.")

            # Add more checks as needed
            
        st.success("There is no mis-configuration inside ELB.")
    except Exception as e:
        st.error(f"Error checking ELB configuration: {str(e)}")

# Function to check AWS Config Rules
def check_aws_config_rules(config_client):
    st.subheader("AWS Config Rules")
    try:
        response = config_client.describe_config_rules()
        non_compliant_rules = [rule['ConfigRuleName'] for rule in response['ConfigRules'] if rule['Compliance']['ComplianceType'] != 'COMPLIANT']
        if non_compliant_rules:
            st.error(f"The following AWS Config rules are not compliant: {', '.join(non_compliant_rules)}")
        else:
            st.success("All AWS Config rules are compliant.")
    except Exception as e:
        st.error(f"Error checking AWS Config rules: {str(e)}")

# Function to check AWS WAF Configuration
def check_aws_waf_configuration(waf_client):
    st.subheader("AWS WAF Configuration")
    try:
        response = waf_client.list_web_acls()
        if 'WebACLs' in response:
            waf_acls = response['WebACLs']
            if waf_acls:
                st.success("AWS WAF configurations checked successfully.")
            else:
                st.error("No AWS WAF web ACLs found.")
        else:
            st.error("Error retrieving AWS WAF web ACLs.")
    except Exception as e:
        st.error(f"Error checking AWS WAF configuration: {str(e)}")

def ec2_vulnerability_scanner():
    
    # AWS region selection
    region_name = st.selectbox("Select AWS Region", ['us-east-1', 'us-east-2', 'us-west-1', 'us-west-2', 'ca-central-1', 'eu-west-1', 'eu-west-2', 'eu-west-3', 'eu-central-1', 'ap-northeast-1', 'ap-northeast-2', 'ap-southeast-1', 'ap-southeast-2', 'ap-south-1', 'sa-east-1'])

    if st.button("Scan EC2"):
        try:
            # Load and decrypt credentials
            aws_access_key_id, aws_secret_access_key, _ = load_credentials()

            # Initialize boto3 clients with credentials
            ec2_client = boto3.client('ec2', region_name=region_name, aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key)
            iam_client = boto3.client('iam', region_name=region_name, aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key)
            elb_client = boto3.client('elb', region_name=region_name, aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key)
            config_client = boto3.client('config', region_name=region_name, aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key)
            waf_client = boto3.client('waf', region_name=region_name, aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key)

            # Check various configurations
            check_security_groups(ec2_client)
            check_all_traffic_security_groups(ec2_client)
            check_open_ports(ec2_client)
            check_iam_roles_policies(iam_client)
            check_ebs_encryption(ec2_client)
            check_single_subnet_vpc(ec2_client)
            check_imds_restriction(ec2_client)
            check_security_patching(ec2_client)
            check_termination_protection(ec2_client)
            check_elb_configuration(elb_client)
            check_aws_config_rules(config_client)
            check_aws_waf_configuration(waf_client)
            
        except Exception as e:
            st.error(f"An error occurred: {str(e)}")
