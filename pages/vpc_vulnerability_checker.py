import streamlit as st
import boto3
from botocore.exceptions import ClientError
from cryptography.fernet import Fernet
from config import CREDENTIALS_FILE, ENCRYPTION_KEY_FILE

# Function to load encryption key
def load_key():
    with open(ENCRYPTION_KEY_FILE, 'rb') as f:
        return f.read()

# Initialize Fernet cipher suite with loaded encryption key
key = load_key()
cipher_suite = Fernet(key)

# Function to decrypt data
def decrypt_data(encrypted_data):
    decrypted_data = cipher_suite.decrypt(encrypted_data.encode())
    return decrypted_data.decode()

# Function to load credentials from file and decrypt them
def load_credentials():
    with open(CREDENTIALS_FILE, 'r') as f:
        lines = f.readlines()
        access_key = decrypt_data(lines[0].split(': ')[1].strip())
        secret_key = decrypt_data(lines[1].split(': ')[1].strip())
        region = lines[2].split(': ')[1].strip()
        return access_key, secret_key, region

# Function to initialize EC2 client
def initialize_ec2_client(aws_access_key_id, aws_secret_access_key, region_name):
    return boto3.client('ec2', aws_access_key_id=aws_access_key_id,
                        aws_secret_access_key=aws_secret_access_key,
                        region_name=region_name)

# Function to check public subnet configuration
def check_public_subnets(ec2_client, vpc_id):
    st.subheader("Public Subnet Configuration")
    try:
        response = ec2_client.describe_subnets(Filters=[{'Name': 'vpc-id', 'Values': [vpc_id]}])
        for subnet in response['Subnets']:
            if subnet['MapPublicIpOnLaunch']:
                st.warning(f"Public subnet detected: {subnet['SubnetId']}")
                # Additional checks or information can be added here
    except Exception as e:
        st.error(f"Error checking public subnet configuration: {str(e)}")

# Function to check security group settings
def check_security_groups(ec2_client, vpc_id):
    st.subheader("Security Group Settings")
    try:
        response = ec2_client.describe_security_groups(Filters=[{'Name': 'vpc-id', 'Values': [vpc_id]}])
        for sg in response['SecurityGroups']:
            st.write(f"Security Group: {sg['GroupName']}")
            # Additional checks or information can be added here
    except Exception as e:
        st.error(f"Error checking security group settings: {str(e)}")

# Function to check network ACLs
def check_network_acls(ec2_client, vpc_id):
    st.subheader("Network ACLs")
    try:
        response = ec2_client.describe_network_acls(Filters=[{'Name': 'vpc-id', 'Values': [vpc_id]}])
        for acl in response['NetworkAcls']:
            st.write(f"Network ACL: {acl['NetworkAclId']}")
            # Additional checks or information can be added here
    except Exception as e:
        st.error(f"Error checking network ACLs: {str(e)}")

# Function to check VPC flow logs
def check_flow_logs(ec2_client, vpc_id):
    st.subheader("Flow Logs")
    try:
        response = ec2_client.describe_flow_logs(Filters=[{'Name': 'resource-id', 'Values': [vpc_id]}])
        if response['FlowLogs']:
            st.success("Flow Logs are enabled for this VPC.")
        else:
            st.warning("Flow Logs are not enabled for this VPC.")
    except Exception as e:
        st.error(f"Error checking flow logs: {str(e)}")

# Function to check VPC peering and VPN connections
def check_peering_vpn_connections(ec2_client, vpc_id):
    st.subheader("VPC Peering and VPN Connections")
    try:
        response = ec2_client.describe_vpc_peering_connections(Filters=[{'Name': 'requester-vpc-info.vpc-id', 'Values': [vpc_id]}])
        if response['VpcPeeringConnections']:
            st.warning("VPC peering connections found.")
            # Additional checks or information can be added here
        else:
            st.success("No VPC peering connections found.")
    except Exception as e:
        st.error(f"Error checking VPC peering connections: {str(e)}")

# Function to check route tables
def check_route_tables(ec2_client, vpc_id):
    st.subheader("Route Tables")
    try:
        response = ec2_client.describe_route_tables(Filters=[{'Name': 'vpc-id', 'Values': [vpc_id]}])
        for route_table in response['RouteTables']:
            st.write(f"Route Table: {route_table['RouteTableId']}")
            # Additional checks or information can be added here
    except Exception as e:
        st.error(f"Error checking route tables: {str(e)}")

# Function to check subnet sizing
def check_subnet_sizing(ec2_client, vpc_id):
    st.subheader("Subnet Sizing")
    try:
        response = ec2_client.describe_subnets(Filters=[{'Name': 'vpc-id', 'Values': [vpc_id]}])
        for subnet in response['Subnets']:
            st.write(f"Subnet: {subnet['SubnetId']}")
            # Additional checks or information can be added here
    except Exception as e:
        st.error(f"Error checking subnet sizing: {str(e)}")

# Function to check internet and NAT gateways
def check_gateways(ec2_client, vpc_id):
    st.subheader("Internet and NAT Gateways")
    try:
        response = ec2_client.describe_internet_gateways(Filters=[{'Name': 'attachment.vpc-id', 'Values': [vpc_id]}])
        if response['InternetGateways']:
            st.success("Internet Gateway is attached to this VPC.")
        else:
            st.warning("No Internet Gateway found for this VPC.")
        
        response = ec2_client.describe_nat_gateways(Filters=[{'Name': 'vpc-id', 'Values': [vpc_id]}])
        if response['NatGateways']:
            st.success("NAT Gateway(s) are attached to this VPC.")
        else:
            st.warning("No NAT Gateway found for this VPC.")
    except Exception as e:
        st.error(f"Error checking gateways: {str(e)}")

# Function to check VPC endpoints
def check_vpc_endpoints(ec2_client, vpc_id):
    st.subheader("VPC Endpoints")
    try:
        response = ec2_client.describe_vpc_endpoints(Filters=[{'Name': 'vpc-id', 'Values': [vpc_id]}])
        if response['VpcEndpoints']:
            st.success("VPC Endpoint(s) found for this VPC.")
            # Additional checks or information can be added here
        else:
            st.warning("No VPC Endpoint found for this VPC.")
    except Exception as e:
        st.error(f"Error checking VPC endpoints: {str(e)}")

# Function for custom menu
def custom_menu():
    st.sidebar.title('Custom Menu')
    st.sidebar.header('Navigation')
    menu_selection = st.sidebar.radio('Go to:', ('Home', 'Settings', 'About'))
    
    if menu_selection == 'Home':
        st.sidebar.success("Welcome to the AWS VPC Vulnerability Checker!")
    elif menu_selection == 'Settings':
        st.sidebar.info("Customize your settings here.")
    elif menu_selection == 'About':
        st.sidebar.warning("This is a demo application.")

# Main function
def vpc_vuln_checker():
    # AWS credentials setup
    aws_access_key_id, aws_secret_access_key, region_name = load_credentials()

    region_name = st.selectbox("Select AWS Region", ['us-east-1', 'us-east-2', 'us-west-1', 'us-west-2', 'ca-central-1', 'eu-west-1', 'eu-west-2', 'eu-west-3', 'eu-central-1', 'ap-northeast-1', 'ap-northeast-2', 'ap-southeast-1', 'ap-southeast-2', 'ap-south-1', 'sa-east-1'])

    if st.button("Scan VPC"):
        if aws_access_key_id and aws_secret_access_key and region_name:
            try:
                # Initialize Boto3 client
                ec2_client = initialize_ec2_client(aws_access_key_id, aws_secret_access_key, region_name)

                # Get all VPCs in the specified region
                vpcs_response = ec2_client.describe_vpcs()
                vpcs = vpcs_response['Vpcs']
                for vpc in vpcs:
                    vpc_id = vpc['VpcId']
                    st.subheader(f"Checking VPC: {vpc_id}")
                    # Check various configurations for each VPC
                    check_public_subnets(ec2_client, vpc_id)
                    check_security_groups(ec2_client, vpc_id)
                    check_network_acls(ec2_client, vpc_id)
                    check_flow_logs(ec2_client, vpc_id)
                    check_peering_vpn_connections(ec2_client, vpc_id)
                    check_route_tables(ec2_client, vpc_id)
                    check_subnet_sizing(ec2_client, vpc_id)
                    check_gateways(ec2_client, vpc_id)
                    check_vpc_endpoints(ec2_client, vpc_id)

            except Exception as e:
                st.error(f"An error occurred: {str(e)}")
    # Handle return button action
    #return_button = st.button("Return to Chatbot")
    #if return_button:
    #    st.write("Redirecting to the previous page...")
    #    st.switch_page("pages/chatbot.py")