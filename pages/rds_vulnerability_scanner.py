import streamlit as st
import boto3
from botocore.exceptions import NoCredentialsError, PartialCredentialsError
from cryptography.fernet import Fernet
from config import CREDENTIALS_FILE, ENCRYPTION_KEY_FILE

AWS_REGIONS = [
    'us-east-1', 'us-east-2', 'us-west-1', 'us-west-2',
    'ca-central-1', 'eu-west-1', 'eu-west-2', 'eu-west-3',
    'eu-central-1', 'ap-northeast-1', 'ap-northeast-2', 'ap-southeast-1',
    'ap-southeast-2', 'ap-south-1', 'sa-east-1'
]

# Function to load encryption key
def load_key():
    with open(ENCRYPTION_KEY_FILE, 'rb') as f:
        return f.read()

# Initialize Fernet cipher suite with loaded encryption key
key = load_key()
cipher_suite = Fernet(key)

# Function to decrypt data
def decrypt_data(encrypted_data):
    decrypted_data = cipher_suite.decrypt(encrypted_data.encode())
    return decrypted_data.decode()

# Function to load credentials from file and decrypt them
def load_credentials():
    with open(CREDENTIALS_FILE, 'r') as f:
        lines = f.readlines()
        access_key = decrypt_data(lines[0].split(': ')[1].strip())
        secret_key = decrypt_data(lines[1].split(': ')[1].strip())
        return access_key, secret_key

# Load and decrypt credentials
aws_access_key_id, aws_secret_access_key = load_credentials()

# Function to check for RDS configuration vulnerabilities
def check_rds_vulnerabilities(region):
    vulnerabilities = []
    try:
        client = boto3.client(
            'rds',
            region_name=region,
            aws_access_key_id=aws_access_key_id,
            aws_secret_access_key=aws_secret_access_key
        )
        ec2_client = boto3.client(
            'ec2',
            region_name=region,
            aws_access_key_id=aws_access_key_id,
            aws_secret_access_key=aws_secret_access_key
        )
        instances = client.describe_db_instances()

        for instance in instances['DBInstances']:
            instance_id = instance['DBInstanceIdentifier']

            # Check if the instance is publicly accessible
            if instance['PubliclyAccessible']:
                vulnerabilities.append(f'Instance {instance_id} is publicly accessible.')

            # Check if the instance is not encrypted
            if not instance.get('StorageEncrypted'):
                vulnerabilities.append(f'Instance {instance_id} is not encrypted.')

            # Check if the instance is using default port (3306 for MySQL, 5432 for PostgreSQL, etc.)
            default_ports = [3306, 5432]
            if instance['Endpoint']['Port'] in default_ports:
                vulnerabilities.append(f'Instance {instance_id} is using a default port ({instance["Endpoint"]["Port"]}).')

            # Check if backups are not enabled (i.e., BackupRetentionPeriod is 0)
            if instance.get('BackupRetentionPeriod', 0) == 0:
                vulnerabilities.append(f'Instance {instance_id} does not have backups enabled.')

            # Check if the instance has Multi-AZ enabled
            if not instance.get('MultiAZ', False):
                vulnerabilities.append(f'Instance {instance_id} does not have Multi-AZ enabled.')

            # Check if the instance has Performance Insights enabled
            if not instance.get('PerformanceInsightsEnabled', False):
                vulnerabilities.append(f'Instance {instance_id} does not have Performance Insights enabled.')

            # Check if the instance has IAM Database Authentication enabled
            if not instance.get('IAMDatabaseAuthenticationEnabled', False):
                vulnerabilities.append(f'Instance {instance_id} does not have IAM Database Authentication enabled.')

            # Check if the instance has CloudWatch Logs exports enabled
            if 'LogTypesToExport' not in instance:
                vulnerabilities.append(f'Instance {instance_id} does not have CloudWatch Logs exports enabled.')

            # Check for overly permissive security groups
            sg_ids = instance['VpcSecurityGroups']
            for sg_id in sg_ids:
                sg = ec2_client.describe_security_groups(GroupIds=[sg_id['VpcSecurityGroupId']])['SecurityGroups'][0]
                for permission in sg['IpPermissions']:
                    for ip_range in permission.get('IpRanges', []):
                        if ip_range.get('CidrIp') == '0.0.0.0/0':
                            vulnerabilities.append(f'Instance {instance_id} has an overly permissive security group ({sg["GroupName"]} with CIDR 0.0.0.0/0).')

            # Ensure instance is using the latest engine version
            latest_engine_versions = client.describe_db_engine_versions(
                Engine=instance['Engine'],
                DefaultOnly=True
            )['DBEngineVersions'][0]
            if instance['EngineVersion'] != latest_engine_versions['EngineVersion']:
                vulnerabilities.append(f'Instance {instance_id} is not using the latest engine version ({instance["EngineVersion"]} vs {latest_engine_versions["EngineVersion"]}).')

    except NoCredentialsError:
        vulnerabilities.append("AWS credentials not found.")
    except PartialCredentialsError:
        vulnerabilities.append("Incomplete AWS credentials.")
    except Exception as e:
        vulnerabilities.append(str(e))

    return vulnerabilities

# Function to run the scanner via Streamlit
def run_scanner():
    
    region = st.selectbox('Select AWS Region', AWS_REGIONS)

    if st.button('Scan RDS'):
        with st.spinner('Scanning...'):
            vulnerabilities = check_rds_vulnerabilities(region)
        if vulnerabilities:
            st.error('Vulnerabilities found:')
            for vulnerability in vulnerabilities:
                st.write(f"- {vulnerability}")
        else:
            st.success('No vulnerabilities found!')
